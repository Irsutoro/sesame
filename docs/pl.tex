\documentclass{article}

\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[hidelinks]{hyperref}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{float}
\usepackage{relsize}
\usepackage{chngcntr}
\counterwithin{figure}{section}

\newcommand{\insertprojectname}{\textit{Sesame }}
\title{
    Ochrona Danych
    \\
    [0.2em]\smaller{}
    Projekt
    \\
    Menadżer haseł \insertprojectname}
\author{
    Patryk Mroczyński 126810
    \\
    patryk.mroczynski@student.put.poznan.pl
    \\
    Daniel Staśczak 126816
    \\
    daniel.stasczak@student.put.poznan.pl
    \\
    Jakub Wiśniewski 126824
    \\
    jakub.t.wisniewski@student.put.poznan.pl
}
\date{\today}

\begin{document}
    \maketitle

    \newpage
    \tableofcontents
    \listoffigures
    \listoftables

    \newpage

    \section{Charakterystyka ogólna projektu}
    \paragraph{}Aplikacja \insertprojectname jest menadżerem haseł, ułatwiającym zarządzanie unikalnymi i bezpiecznymi hasłami w różnych serwisach. Umożliwia ona bezpieczne przechowywanie haseł na serwerze oraz zezwala na dostęp do nich tylko dla użytkownika, który zna hasło do serwisu. Użytkownik ma możliwość wprowadzanie wpisu do bazy danych, który zawiera zaszyfrowane hasło do danego serwisu oraz etykietę, która ułatwia użytkownikowi zidentyfikowanie do jakiego celu przechowywane jest hasło we wpisie. Szyfrowanie oraz odszyfrowanie dzieje się po stronie klienta, dzięki czemu niemożliwa jest ingerencja osób mających dostęp do serwera. Operacje te są zautomatyzowane, dzięki czemu użytkownik nie musi posiadać wiedzy dotyczącej kryptografii.

    \section{Architektura systemu}
    \paragraph{}System oparty jest na modelu klient-serwer. Aplikacje klienckie udostępniają interfejs graficzny, umożliwiający korzystanie z serwisu osobom nietechnicznym. Na maszynie serwerowej uruchomiona jest relacyjna baza danych oraz program udostępniający API aplikacjom klienckim. API serwerowe pozwala wykonywać użytkownikom udostępnione operacje na bazie danych. W oparciu o API serwerowe, stworzone zostały API klienckie w poszczególnych językach programowaniach, które są dedykowane konkretnym platformom i które udostępniają funkcjonalności, ułatwiające implementacje aplikacji klienckich.

    \subsection{Baza danych}
    \paragraph{}Baza danych, przedstawiona na rysunku \ref{fig:db} zawiera trzy główne tabele - user, password oraz device. Tabela user zawiera informacje o użytkowniku, niezbędne do prawidłowego i bezpiecznego funkcjonowania aplikacji oraz umożliwiające użytkownikom korzystanie z funkcjonalności systemu. Tabela password zawiera wpisy zawierające zaszyfrowane hasła dla konkretnych użytkowników, a tabela device umożliwia korzystanie z aplikacji tylko zweryfikowanym przez użytkownika urządzeniom.

    \begin{figure}[H]
		\centering
		\includegraphics[width=1\linewidth]{assets/db.png}
		\caption[]{Model bazy danych}
		\label{fig:db}
	\end{figure}

    \subsection{Serwisy}
    Tutaj będą opisane udostępnione serwisy.

    \section{Bezpieczeństwo}
    \paragraph{}W rozdziale opisane zostały wszystkie zastosowane w aplikacji aspekty bezpieczeństwa. Wymienione zostały wszystkie zastosowane mechanizmy na każdym etapie działania systemu.

    \paragraph{}Mechanizmem zabezpieczającym ujawnienie hasła użytkownika poprzez wyciek informacji z bazy danych jest wykorzystanie funkcji  PBKDF2, która zapewnia większe bezpieczeństwo od używania funkcji skrótu. Została ona zaprojektowana do utrudnienia prób ataków brute-force oraz słownikowych. Wydłuża ona czas potrzebny na obliczenie pojedynczego skrótu w stopniu zależnym od zastosowanej liczby iteracji, a wykorzystanie soli, która jest indywidualna dla każdego użytkownika i dodawana do każdego hasła, zapewnia różne skróty dla identycznych haseł różnych użytkowników. Dzięki temu zmniejszona jest skuteczność tablic tęczowych - atakujący musiałby tworzyć osobne tablice dla każdej soli.

    \paragraph{}Dzięki użyciu protokołu HTTPS, przechwycenie przesyłanych danych jest bardzo trudnie, ale pozostaje problem widoczności nieprzetworzonego hasła po stronie serwera. Aby zabezpieczyć użytkowników przed wykorzystaniem tego faktu przez atakujących, wykorzystana zostaje ponownie funkcja PBKDF2, tym razem po stronie klienta. Jako sól użyta zostaje wynik funkcji skrótu nieprzetworzonej nazwy użytkownika w połączeniu z nieprzetworzonym hasłem, a liczba iteracji jest mniejsza niż po stronie serwerowej, aby użytkownik nie odczuł wykonywanych operacji. Sama nazwa użytkownika zostaje przesłana na serwer jako wynik funkcji skrótu.

    \paragraph{}Aby zmniejszyć prawdopodobieństwo przechwycenia pakietu zawierającego hasło użytkownika, wykorzystane zostały tokeny JWT. Dzięki temu aplikacja kliencka po poprawnym logowaniu otrzymuje token zawierający informacje niezbędne do wykonywania kolejnych zapytań (takie jak skrót nazwy użytkownika czy czas wygaśnięcia tokenu). Całość tokenu jest podpisana za pomocą algorytmu kryptograficznego HMAC, wykorzystującego sekret serwerowy, co zapewnia autentyczność i nienaruszalność tych danych. Dodatkowo dodawany jest kolejny sekret (przechowywany w bazie danych), który jest unikalny dla każdego użytkownika, dzięki czemu, po jego wykryciu sekretu serwerowego przez atakującego, niemożlwe jest fałszowanie podpisu dla każdego użytkownika. Sekret serwerowy jest zmieniany co określony odcinek czasu.

    \paragraph{}Każdorazowe logowanie na nowym (nieautoryzowanym wcześniej) urządzeniu powoduje wysłanie wiadomości e-mail do użytkownika, aby ten mógł zweryfikować czy akcja została wykonana na jego urządzeniu, czy jest to próba włamania. Dzięki zastosowaniu tego mechanizmu, dostęp do danych użytkownika otrzymują tylko urządzenia należące do niego. Aby umożliwić takie zabezpieczenie, aplikacja kliencka musi wysyłać skrót swojego identyfikatora, którym może być np. adres MAC komputera czy fingerprint przeglądarki. Dopiero po poprawnym zweryfikowaniu hasła i identyfikatora, generowany jest token JWT, którego czas wygaśnięcia to krótki odcinek czasu (dzięki czemu nawet w przypadku przechwycenia tokenu, atakujący można korzystać z niego tylko przez chwilę).

    \paragraph{}Po każdej interakcji aplikacji klienckiej z serwerem, zostaje dodany wpis do logów, który zawiera informacje o użytkowniku, adresie IP, akcji, która została wykonana oraz o powodzeniu akcji. Dzięki temu zapewniona jest niezaprzeczalność i rozliczalność, co pozwala na śledzenie podejrzanych aktywności oraz przeciwdziałanie im.

    \paragraph{}Hasła zapisane przez użytkownika, przechowywane na serwerze są w postaci zaszyfrowanej symetrycznie. Użytkownik może wybrać czy do odszyfrowania hasła chce używać zmodyfikowanego przez aplikację kliencką hasła do serwisu czy użyć osobnego klucza, podanego przez użytkownika. Całość szyfrowania i deszyfrowania odbywa się w aplikacji klienckiej, dzięki czemu klucz nigdy nie wydostaje się poza urządzenie użytkownika.

    \paragraph{}Do generowania soli oraz sekretów po stronie serwera używane są algorytmy wykorzystujące kryptograficznie bezpieczne źródło losowości (np. \texttt{/dev/urandom} w przypadku systemów opartych o UNIX lub \texttt{CryptGenRandom} w przypadku systemów Windows).


    %jwt - DONE, hashe - DONE, https - DONE, zautoryzowane urządzenia - DONE, logi - DONE, enkrypcja haseł - DONE, generowane tokeny(z sekretem), /dev/urandom



    \section{Wymagania}
    \paragraph{}W rozdziale zostały opisane wymagania funkcjonalne oraz niefunkcjonalne serwera, aplikacji klienckich oraz komunikacji między nimi wraz z podziałem na aktorów.

    \subsection{Wymagania funkcjonalne}
    Tu będą wymagania funkcjonalne.

    \subsection{Wymagania niefunkcjonalne}
    A tutaj niefunkcjonalne.
    % Kryptograficznie bezpieczne źródło losowości dla aplikacji serwerowej.

    \section{Narzędzia, środowiska, biblioteki}
    Używane narzędzia.

    \section{Diagramy UML}
    Diagramy ułatwiające spójną implementację aplikacji.

    \section{Możliwości rozwoju}
    Plany na przyszłość.

\end{document}
